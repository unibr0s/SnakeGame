<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>Snake Game with Head/Body/Tail Artwork</title>
    <style>
      body {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        height: 100vh;
        margin: 0;
        background: #f0f0f0;
        font-family: sans-serif;
      }
      #gameCanvas {
        border: 2px solid #333;
        background: #eee;
        box-shadow: 2px 2px 10px rgba(0, 0, 0, 0.1);
        border-radius: 12px;
      }
      #score {
        font-size: 1.2rem;
        margin-bottom: 0.5rem;
      }
      #controls {
        margin-top: 1rem;
        font-size: 0.9rem;
      }
    </style>
  </head>
  <body>
    <div id="score">Score: 0</div>
    <!-- A 20×20 grid if gridSize=32, so the canvas is 640×640 -->
    <canvas id="gameCanvas" width="800" height="800"></canvas>
    <div id="controls">Use Arrow Keys or W/A/S/D to move</div>

    <script>
      const canvas = document.getElementById('gameCanvas');
      const ctx = canvas.getContext('2d');
      const scoreDisplay = document.getElementById('score');

      // Grid size: 40 for 40×40 images
      const gridSize = 40;

      // Initial snake with direction
      let snake = [{ x: 10, y: 10, dir: { x: 1, y: 0 } }];
      let direction = { x: 1, y: 0 };

      // Initial food
      let food = { x: 15, y: 10 };

      let score = 0;
      let gameOver = false;

      // Load custom images (head, body, tail, and food)
      const snakeHeadImg = new Image();
      snakeHeadImg.src = 'assets/snake_head.png'; // Replace path as needed

      const snakeBodyImg = new Image();
      snakeBodyImg.src = 'assets/snake_body.png'; // Replace path as needed

      const snakeTailImg = new Image();
      snakeTailImg.src = 'assets/snake_tail.png'; // Replace path as needed

      const foodImg = new Image();
      foodImg.src = 'assets/food.png'; // Replace path as needed

      const snakeCornerRightImg = new Image();
      snakeCornerRightImg.src = 'assets/snake_corner_right.png';

      const snakeCornerLeftImg = new Image();
      snakeCornerLeftImg.src = 'assets/snake_corner_left.png';

      function drawGame() {
        if (gameOver) {
          return;
        }
        updatePosition();
        drawBackground();
        drawFood();
        drawSnake();
        checkCollision();
        scoreDisplay.textContent = `Score: ${score}`;
      }

      function drawBackground() {
        ctx.fillStyle = '#fff';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }

      function drawSnake() {
        for (let i = 0; i < snake.length; i++) {
          let segment = snake[i];
          let imageToDraw;
          let angle = getAngle(segment.dir);

          if (i === 0) {
            // Head
            imageToDraw = snakeHeadImg;
          } else if (i === snake.length - 1) {
            // Tail
            imageToDraw = snakeTailImg;
            const prevSegment = snake[i - 1];
            const dx = prevSegment.x - segment.x;
            const dy = prevSegment.y - segment.y;
            // Handle wrap-around
            if (Math.abs(dx) > 1) angle = dx > 0 ? Math.PI : 0;
            else if (Math.abs(dy) > 1) angle = dy > 0 ? Math.PI/2 : -Math.PI/2;
            else angle = getAngle({ x: dx, y: dy });
          } else {
            // Body segments
            const prevSegment = snake[i - 1];
            const nextSegment = snake[i + 1];
            
            // Calculate directions
            const dx1 = prevSegment.x - segment.x;
            const dy1 = prevSegment.y - segment.y;
            const dx2 = nextSegment.x - segment.x;
            const dy2 = nextSegment.y - segment.y;

            // Handle wrap-around cases
            const fromPrev = {
                x: Math.abs(dx1) > 1 ? -Math.sign(dx1) : dx1,
                y: Math.abs(dy1) > 1 ? -Math.sign(dy1) : dy1
            };
            const toNext = {
                x: Math.abs(dx2) > 1 ? -Math.sign(dx2) : dx2,
                y: Math.abs(dy2) > 1 ? -Math.sign(dy2) : dy2
            };

            // Detect if this is a turn
            if ((fromPrev.x !== 0 && toNext.y !== 0) || (fromPrev.y !== 0 && toNext.x !== 0)) {
                // It's a turn - check if it's clockwise or counter-clockwise
                const isClockwise = 
                    (fromPrev.x > 0 && toNext.y > 0) ||   // right to down
                    (fromPrev.y > 0 && toNext.x < 0) ||   // down to left
                    (fromPrev.x < 0 && toNext.y < 0) ||   // left to up
                    (fromPrev.y < 0 && toNext.x > 0);     // up to right

                imageToDraw = isClockwise ? snakeCornerRightImg : snakeCornerLeftImg;
            } else {
                // Straight segment
                imageToDraw = snakeBodyImg;
            }

            angle = getAngle({ x: fromPrev.x, y: fromPrev.y });
          }

          ctx.save();
          ctx.translate(
            segment.x * gridSize + gridSize / 2,
            segment.y * gridSize + gridSize / 2
          );
          ctx.rotate(angle);
          ctx.drawImage(imageToDraw, -gridSize / 2, -gridSize / 2, gridSize, gridSize);
          ctx.restore();
        }
      }

      function getAngle(direction) {
        if (direction.x === 1) return 0;        // Right
        if (direction.x === -1) return Math.PI; // Left
        if (direction.y === 1) return Math.PI * 0.5;  // Down
        if (direction.y === -1) return Math.PI * 1.5; // Up
        return 0;
      }

      function drawFood() {
        ctx.drawImage(
          foodImg,
          food.x * gridSize,
          food.y * gridSize,
          gridSize,
          gridSize
        );
      }

      function updatePosition() {
        const newHead = {
          x: snake[0].x + direction.x,
          y: snake[0].y + direction.y,
          dir: direction
        };

        const maxCellsX = canvas.width / gridSize;
        const maxCellsY = canvas.height / gridSize;

        if (newHead.x < 0) newHead.x = maxCellsX - 1;
        else if (newHead.x >= maxCellsX) newHead.x = 0;
        if (newHead.y < 0) newHead.y = maxCellsY - 1;
        else if (newHead.y >= maxCellsY) newHead.y = 0;

        // Move snake
        snake.unshift(newHead);

        // Check if snake eats food
        if (newHead.x === food.x && newHead.y === food.y) {
          score++;
          placeFood();
        } else {
          snake.pop();
        }
      }

      function placeFood() {
        const maxCellsX = canvas.width / gridSize;
        const maxCellsY = canvas.height / gridSize;
        food.x = Math.floor(Math.random() * maxCellsX);
        food.y = Math.floor(Math.random() * maxCellsY);
      }

      function checkCollision() {
        for (let i = 1; i < snake.length; i++) {
          if (snake[0].x === snake[i].x && snake[0].y === snake[i].y) {
            gameOver = true;
            alert(`Game Over! Your score is ${score}`);
            resetGame();
            break;
          }
        }
      }

      function resetGame() {
        snake = [{ x: 10, y: 10, dir: { x: 1, y: 0 } }];
        direction = { x: 1, y: 0 };
        score = 0;
        food = { x: 15, y: 10 };
        gameOver = false;
      }

      // Keyboard controls
      document.addEventListener('keydown', (e) => {
        switch (e.key) {
          case 'ArrowLeft':
          case 'a':
          case 'A':
            if (snake[0].dir.x !== 1) {
              direction = { x: -1, y: 0 };
            }
            break;
          case 'ArrowUp':
          case 'w':
          case 'W':
            if (snake[0].dir.x !== 0 || snake[0].dir.y !== 1) {
              direction = { x: 0, y: -1 };
            }
            break;
          case 'ArrowRight':
          case 'd':
          case 'D':
            if (snake[0].dir.x !== -1) {
              direction = { x: 1, y: 0 };
            }
            break;
          case 'ArrowDown':
          case 's':
          case 'S':
            if (snake[0].dir.x !== 0 || snake[0].dir.y !== -1) {
              direction = { x: 0, y: 1 };
            }
            break;
        }
      });

      // Update game on an interval (150 ms)
      setInterval(drawGame, 150);
    </script>
  </body>
</html>
